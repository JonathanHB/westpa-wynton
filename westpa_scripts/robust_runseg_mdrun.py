#Jonathan Borowsky
#091923
#westpa gromacs file copy error handling

import sys
import os
import time
#os.system(f"echo {sys.argv[1]} > /wynton/home/grabe/jborowsky/aac1/westpa-07/test-io-log.txt")

#argument key (variables from runseg.sh)
#1: $PWD 
#2: $GMX
#3: $OMP_NUM_THREADS
#4: $GPU_ID

log_times = False
time_log_path = "../../../time_logs"

t1 = time.time()

round_str = sys.argv[1].split("/")[-2]
walker_str = sys.argv[1].split("/")[-1]

walker_num = int(walker_str)

#backup west.h5
#note that this is the file at the start of the round (i.e. west-000005.h5 has the data from rounds 1-4)
#it is important to run this before any segments can complete so that you don't get part of the current round (i.e. the first 23 walkers of round 5)
if walker_num == 0:
	if not os.path.exists(f"../../../h5-backups/west-{round_str}.h5"):
		os.system(f"cp ../../../west.h5 ../../../h5-backups/west-{round_str}.h5")
	#beware that this does not handle multiple layers of overwriting; it keeps only the most recently replaced file
	else:
		os.system(f"mv ../../../h5-backups/west-{round_str}.h5 ../../../h5-backups/overwritten-west-{round_str}.h5; cp ../../../west.h5 ../../../h5-backups/west-{round_str}.h5")

t2 = time.time()

if log_times: os.system(f"echo h5-backup={t2-t1} >> {time_log_path}/time-{round_str}-{walker_str}.log")

#-------------------------------------------------------------------------------------------------

tgmx_total = 0

t3 = time.time()

#lines signalling fatal error requiring restart
#found in the log file in seg_logs/
error_lines = [\
 	"Asynchronous H2D copy failed",\
 	"Asynchronous D2H copy failed",\
 	"The total potential energy is nan, which is not finite.",\
 	"Unexpected cudaStreamQuery failure: an illegal memory access was encountered",\
	"Could not register the host memory for page locking for GPU transfers.",\
	"cudaErrorMemoryAllocation: out of memory",\
	"bytes failed: out of memory",\
	"cudaMalloc failure",\
	"cudaStreamSynchronize failed",\
	"Synchronous D2H copy failed",\
	"Synchronous H2D copy failed",\
	"incompatible GPUs: 0. Request only compatible GPUs."]

#whole error with variable number: cudaMallocHost of size 4660224 bytes failed: out of memory

#acquire a list of all files present before the simulation is run
# these are the files not moved to a storage folder when the run has to be restarted 
mdrun_inputs = os.listdir(".")

l_inds = []

#run gmx mdrun until a run completes successfully, then exit
for run_ind in range(16):
	
	tgmx1 = time.time()

	gmx_mdr_out = os.system("export CUDA_VISIBLE_DEVICES=$SGE_GPU; %s mdrun -s  seg.tpr -o seg.trr -c  seg.gro -e seg.edr \
	  -cpi state.cpt -g seg.log -nb gpu -pme gpu -bonded gpu \
	  -maxh 2 -cpt 10 -nt %s -ntmpi 1" % (sys.argv[2], sys.argv[3])) 
	  # -gpu_id %s , sys.argv[4]
	  # -gpu_id $SGE_GPU

	tgmx2 = time.time()

	tgmx_total += tgmx2-tgmx1

	crashed = False

	#check if the simulation crashed
	x=0
	for line in open("../../../seg_logs/%s-%s.log" % (round_str, walker_str)):
		for errorline in error_lines:
			if errorline in line.strip() and (x not in l_inds):
				#record the indices of lines with error messages to avoid 
				#repeatedly exiting on the same error if the subsequent gromacs run worked fine
				#this is an issue if the seg_logs/ log file does not copy
				l_inds.append(x)
				os.system("echo %s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (run_ind, round_str, walker_str))
				os.system("echo %s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (x, round_str, walker_str))
				os.system("echo %s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (errorline, round_str, walker_str))
				crashed = True
				break
		if crashed:
			break

		x+=1

	#if no crash has been detected in seg_logs, check that a .gro file is present. Failed runs in which an mdrun job froze may leave no warning in seg_logs.
	if not crashed:
		if not os.path.exists("seg.gro"):
			errorline = "no seg.gro file found"
			os.system("echo %s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (run_ind, round_str, walker_str))
			os.system("echo %s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (errorline, round_str, walker_str))
			crashed = True


	if crashed:

		os.system("echo crashed-%s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (run_ind, round_str, walker_str))

		#move files generated by mdrun to a backup directory for future inspection of root causes of errors
		current_files = os.listdir(".")
		failed_run_backup_dir = "failed_run_%s" % run_ind
		os.system("mkdir " + failed_run_backup_dir)

		for cfile in current_files:
			if cfile not in mdrun_inputs:
				os.system("mv %s %s" % (cfile, failed_run_backup_dir))

		#this does not work if the seg_logs file is actively being written to
		#as a result the program repeatedly reads the old error message in the first part of the log file until it crashes
		# try:
		# 	os.system("mv ../../../seg_logs/%s-%s.log %s" % (round_str, walker_str, failed_run_backup_dir))
		# 	reset_linds = True
		# except:
		# 	reset_linds = False
		# 	#print("could not move ../../../seg_logs/%s-%s.log to %s" % (round_str, walker_str, failed_run_backup_dir))
		# if reset_linds:
		# 	l_inds = []


	#proceed if the run did not crash
	else:
		if run_ind != 0:
			os.system("echo finished-nc-%s >> ../../../rrm_logs/rrm-%s-%s-err.log" % (run_ind, round_str, walker_str))
		
		os.system(f"{sys.argv[2]} trjconv -f traj_comp.xtc -o traj_comp_1frame.xtc -b 20") #will need to be adjusted with segment length specified in mdp file
		os.system(f"rm traj_comp.xtc")
		os.system(f"mv traj_comp_1frame.xtc traj_comp.xtc")		
		
		break

t4 = time.time()

if log_times: os.system(f"echo robust-gmx-run={t4-t3} >> {time_log_path}/time-{round_str}-{walker_str}.log")

if log_times: os.system(f"echo gmx-mdrun={tgmx_total} >> {time_log_path}/time-{round_str}-{walker_str}.log")



#Jonathan Borowsky
#091923
#westpa gromacs file copy error handling

import sys
import os
#os.system(f"echo {sys.argv[1]} > /wynton/home/grabe/jborowsky/aac1/westpa-07/test-io-log.txt")

#argument key (variables from runseg.sh)
#1: $PWD 
#2: $GMX
#3: $OMP_NUM_THREADS
#4: $GPU_ID

round_str = sys.argv[1].split("/")[-2]
walker_str = sys.argv[1].split("/")[-1]

walker_num = int(walker_str)

#backup west.h5
#note that this is the file at the start of the round (i.e. west-000005.h5 has the data from rounds 1-4)
#it is important to run this before any segments can complete so that you don't get part of the current round (i.e. the first 23 walkers of round 5)
#if this were more thorough it would explicitly hold all segments until this operation is complete in case walker 0 happens to be running on a particularly slow node
if walker_num == 0:
	if not os.path.exists(f"../../../h5-backups/west-{round_str}.h5"):
		os.system(f"cp ../../../west.h5 ../../../h5-backups/west-{round_str}.h5")
	#beware that this does not handle multiple layers of overwriting; it keeps only the most recently replaced file
	else:
			os.system(f"mv ../../../h5-backups/west-{round_str}.h5 ../../../h5-backups/overwritten-west-{round_str}.h5; cp ../../../west.h5 ../../../h5-backups/west-{round_str}.h5")


#lines signalling fatal error requiring restarts
#found in the log file in seg_logs/
error_lines = [\
 	"Asynchronous H2D copy failed",\
 	"Asynchronous D2H copy failed",\
 	"The total potential energy is nan, which is not finite.",\
 	"Unexpected cudaStreamQuery failure: an illegal memory access was encountered",\
	"Could not register the host memory for page locking for GPU transfers.",\
	"cudaErrorMemoryAllocation: out of memory",\
	"bytes failed: out of memory",\
	"cudaMalloc failure",\
	"cudaStreamSynchronize failed",\
	"Synchronous D2H copy failed",\
	"Synchronous H2D copy failed",\
	"incompatible GPUs: 0. Request only compatible GPUs."]

#whole error with variable number: cudaMallocHost of size 4660224 bytes failed: out of memory

#acquire a list of all files present before the simulation is run
# these are the files not moved to a storage folder when the run has to be restarted 
mdrun_inputs = os.listdir(".")


#run gmx mdrun until a run completes successfully, then exit
for run_ind in range(16):
	
	#os.system("touch test_file.log")
	#os.system("cp ../../../seg_logs/backup-000037-000172.log ../../../seg_logs/000037-000172.log")
	gmx_mdr_out = os.system("%s mdrun -s  seg.tpr -o seg.trr -c  seg.gro -e seg.edr \
	  -cpi state.cpt -g seg.log -nb gpu -pme gpu -bonded gpu \
	  -maxh 2 -cpt 10 -nt %s -gpu_id %s -ntmpi 1" % (sys.argv[2], sys.argv[3], sys.argv[4]))

	crashed = False

	#check if the simulation crashed
	for line in open("../../../seg_logs/%s-%s.log" % (round_str, walker_str)):
		for errorline in error_lines:
			if errorline in line.strip():
				crashed=True
				break
		if crashed:
			break

	if crashed:
		#move files generated by mdrun to a backup directory for future inspection of root causes of errors
		current_files = os.listdir(".")
		failed_run_backup_dir = "failed_run_%s" % run_ind
		os.system("mkdir " + failed_run_backup_dir)

		for cfile in current_files:
			if cfile not in mdrun_inputs:
				os.system("mv %s %s" % (cfile, failed_run_backup_dir))

		os.system("mv ../../../seg_logs/%s-%s.log %s" % (round_str, walker_str, failed_run_backup_dir))
	
	#proceed if the run did not crash
	else:
		break

